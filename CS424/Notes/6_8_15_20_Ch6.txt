** Data Types **
Intro
	defined collection of valid values and operatives
	type descriptor - tells you information that you need to keep with the data type
		descriptor can be thrown away runtime in some cases
		arrays - have several components such as other data types inside it, how many (size)
			some languages keep things like bounds
			some languages let you keep up with how much of the array you've used
Primitive / Non primitive
	hardcoded into the compiler, not defined in terms of other types
	mapped in the compiler to a specific size that you know
	typically considered primitive
		Integer
			most basic, found in hardware
			early languages, declaring integer was given word size
			fortran you could declare how many bytes you wanted (default was 4)
		Float point
			estimate of a real number, scientific notation
		Complex
			hardware that can handle it becomes more primitive
			software written to handle it so it could be made up of two float point
		Decimal
			COBOL arose on hardware that decimal data type
			used to represent fractional values that aren't float (useful for accounting type things)
			Uses BCD
				byte based, descriptor keeps up with decimal
				ex. 10.38
					0001 0000 0011 1000
			Can tell it how you want to deal with extra cents/round
			COBOL
				you tell it how many digits you want after the decimal and before
		Boolean - 
		Character -
	C: doesn't differeitate between bool/char/
		as a community it has been agreed that things such as 0 is special and means null
	C++: bool is an integer. uses macros that changes true/false to 0 and 1
		0 means false in all computations, makes it faster and hardware trips less
	Python: uses true/false
	Boolean/Character: discrete types, that may or may not be interchangable with integers

-Non Primitive
	Character String
		defined operators for it then on boundary of primitive or not
			support slices and substring, counting substring occurrences\
			SnoBall - used to write editors
		Usually implemented as a character array
	Array
		homogeneous collection of data elements stored in consecutive locations, id'd by index
		Issues:
			data type index can be
			subscript index fixed? 
				using 0, 1 or setting your own
				readability/writability
					Ex. Fortran 
						Real A(1900,2000) 	//starting index, ending index
					more readable codebase
			bounds checked at runtime? 
			when does memory get bound to array
				c allows both stack and heap
			multidimensioned, if so number of dimensions allowed
				c is technically 1-D, it treats as single and runs computations on it
				fortran is more multi-dimensioned but up to 7 dimensions
					not orthogonal
			memory binding
				usually a fixed size
					@array (1, 2, 3) 	//perl 
					$array[999] = 7 	//add 7 to that position, array gets bigger
					perl has two arrays: one that does this and the other takes up the space given. Associative array but defined as hash
					...
					a[1] = 11	//AWK (language)
					a[999] = 7
					only stores values given, doesn't fill in all the space
					associative "array" - bc not using an index
		Contiguous Storage
			don't use new, allocates on heap
			ex
				m(3,4)	//matrix with 3 rows and 4 columns
				have 2-d array, Ram is 1-D -> data needs to be laid out in 1-D field
				row major vs column major
				for row = 1 to 3
					for col = 1 to 4
						sum = sum + m(row, col)
			Memory bounding (allocation)
				Static
					global, declared before runtime, can't change
						static int i[100];
				Fixed Stack Dynamic
					point in time you reach that scope, its allocated on stack and its fixed (can't grow or shrink) 
					void f1(int N)
						{
							double sum;
							double A[10]	//some languages allow a parameter instead of preknown size
						}
					declaration, elaboration
						f1 called, N, sum and array pushed to stack
				Fixed Heap Dynamic
					when called the heap allocates whats need for A. A is put on stack but references where you allocated it
					void f2()
						int [] A = new int[10]
				Heap Dynamic
					means the size can change and is managed for you
	Associative Arrays
		indexed by keys used to create thing
		@keys
		get keys
	Enum 
		typedef
			enum days {MON, TUES, 
						1	2
		k = MON + TUES	//stored as an integer, c++
		wouldn't compile for ADA - improves reliability
	Records/Structs
		heterogeneous collection of data within a single unit
		Ex
			Record Person
			begin
				name : string
				age : real
			end
		Operation: assignment, things related to the scope of the record such as print
			print Ra.name
			..
			with RA 
				begin 
					print name 
					print gpa 
				end
		Syntax: 
			saves memory, because code and magnitude use the same bytes. it treats the bits different based on what you call (.code/.magnitude)
				removes reliability and type checking
			union message begin
				int code
				float magnitude
			end
			
	Tuple
	Lists
		sequence, still use index (logical position) everything doesn't have to be same data type
Neither primitive or nonprimitive
	Reference & Pointer types
		Problems:
			memory leaks
				p = new int[100], p[0].....p = null
			dangling pointers
				at one point in time the pointer pointed to a valid piece of memeory but now it doesn't
					s1 = new Student()......s2 = s1
					at some point in time, delete s2   s2 = null
					s2 is deleted and good but s1 is still pointing to an address in the heap but the heap may already be pointing to something else
		Designs: try to get rid of those problems
			tombstones
				attempt to make pointers more robust and reliable
				when you remove a pointer, it leaves a little piece (tombstone) so if a dangling pointer is looking at something tagged tombstone program will error
				drawback: now have tons of tombstones
			lock and key
				attempt to make pointers more robust and reliable
				when object is allocated it gets lock value and when pointed at the pointer gets the address and key
				when accessed key will match lock = good data
				if allocated somewhere else and then try to access the mismatch of lock and key will prevent access. 
			new data type instead of pointers
				reference data type
					removes ability to delete memory explicitly
					java:
						person s1 = new person()
						s2 =s1
						garabage collection, no longer responsible for remembering to delete it
						defacto removes dangling problem to because as a programmer can't delete memory because you can't create it
						reference counter	//java
							tells heap management how many variables are pointing to it
							old java waited until out of memory, everything stopped while it did a full sweep of the heap and got rid of things
								now its incremental so when a counter hits 0, that memory is freed
							when something is set to null, ref count is 0
							incremental mark and sweep
								when convient it frees the memory
					mark and sweep 	//lisp
						any memory not marked is freed
					
		void f3(float *p)
			*p = 0.0
			
		main
			float x
			f3(&x)
		p has value of x 
		
		heap management:
			int *p
			p = new array[100]
			
			main
				p[Adress1]
			heap has some continous array that we're pointing to now
	Type Checking
		A + B -> legal?
		A[I] = value -> legal?
		type descriptor: data in array and bounds. Doesn't live during runtime for non bound checking languages (C++)
			if(I >= 0 && I < max)
				A[i] = value
			else
				throw outofbounds exception
			//whats actually being ran when A[I] = value is encounted in main code
		strongly typed
			all type errors are detected and enforced
			ADA, Java is fairly
		weak typed
			C and assembly
			doesnt detect all type errors
			warning is not error
		Type error categories (type equvalence 
			named: 2 vaules are type equivalent if they have the saem name
			structural: behind the scenes they're the same
			Ex.
			typedef Celcius is float
			typedef Farhenhit is float
			x: Celcius
			y = Far
			// is x = y legal? illega bc not the same type name
			// in structural equivalence they would be legal
			
			typedef LIST1 is am [ARRAY[0...9] of float typedef LIST2 array[0.19] of float
			subtypes allow values to be copied one way
				x: smallint
				y: int
				y = x valid, x = y not. 
		adv/dis